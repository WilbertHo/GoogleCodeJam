import java.io.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Collections;

public class AlwaysTurnLeft {

  private class Tuple {
    public int x;
    public int y;

    public Tuple(int x, int y) {
      this.x = x;
      this.y = y;
    }

    @Override
    public String toString() {
      return String.format("%d,%d", x, y);
    }

    // Auto-generated by Eclipse because Java
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + x;
      result = prime * result + y;
      return result;
    }

    // Auto-generated by Eclipse because Java
    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      Tuple other = (Tuple) obj;
      if (x != other.x)
        return false;
      if (y != other.y)
        return false;
      return true;
    }
  }

  // Pretend we have 4-bit direction vars so we can bitshift
  // right and left, ie bitshift right N->E, left N->W
  private final int NORTH = 0x1;
  private final int WEST = 0x2;
  private final int SOUTH = 0x4;
  private final int EAST = 0x8;

  public static HashMap<Integer, String> key = new HashMap<Integer, String>();

  private int currentFacing;
  private Tuple currentRoom;
  private Tuple startingRoom;
  private Tuple endingRoom;
  private HashMap<Tuple, Integer> maze;

  public AlwaysTurnLeft() {
    // Initially facing south
    currentFacing = SOUTH;

    startingRoom = null;
    endingRoom = null;
    currentRoom = null;

    // Initialize the maze with the first room, which is
    // one step north of the actual entrance
    // We'll remove this room later
    maze = new HashMap<Tuple, Integer>();
  }

  /**
   * Rotate current facing
   * @param currentFacing current direction facing
   * @param direction rotate current facing right or left
   * @return new direction facing
   */
  private int changeFacing(int currentFacing, char direction) {
    switch (direction) {
      case 'R':
        int low = (currentFacing << (4 - 1));
        return (currentFacing >>> 1) | (low > 8 ? 0 : low);
      case 'L':
        int high = currentFacing << 1;
        return (high > 8 ? 0 : high) | (currentFacing >>> (4 - 1));
      default:
        // raise exception
        return currentFacing;
    }
  }

  /**
   * Return direction opposite the current facing.
   */
  private int oppositeFacing() {
    int opposite = changeFacing(currentFacing, 'R');
    return changeFacing(opposite, 'R');
  }

  /**
   * Change the room coordinates depending on the current facing
   */
  private Tuple nextRoom(int currentFacing) {
    int x = currentRoom.x;
    int y = currentRoom.y;

    switch(currentFacing) {
      case 1: // North
        y += 1;
        break;
      case 2: // West
        x -= 1;
        break;
      case 4: // South
        y -= 1;
        break;
      case 8: // East
        x += 1;
        break;
      default:
        break;
    }
    return new Tuple(x, y);
  }

  /**
   * Update room description with entrance or exit
   */
  private void updateRoom(String moves) {
    // (entrance) canMove opposite cur facing
    int possibleMoves;
    if (maze.containsKey(currentRoom)) {
      possibleMoves = maze.get(currentRoom);
    } else {
      possibleMoves = 0 | oppositeFacing();
    }
    // iterate over moves, processing rotations, stop at 'W'
    for (char move: moves.toCharArray()) {
      if (move == 'W') {
        continue;
      } else {
        currentFacing = changeFacing(currentFacing, move);
      }
    }
    // (exit) if 'w', canMove cur Facing
    possibleMoves = possibleMoves | currentFacing;
    int x = currentRoom.x;
    int y = currentRoom.y;
    maze.put(currentRoom, possibleMoves);
    // update the current room depending on the facing
    currentRoom = nextRoom(currentFacing);
  }

  private char mapKey(int possibleMoves) {
    switch (possibleMoves) {
      case 1:
        return '1';
      case 2:
        return '4';
      case 3:
        return '5';
      case 4:
        return '2';
      case 5:
        return '3';
      case 6:
        return '6';
      case 7:
        return '7';
      case 8:
        return '8';
      case 9:
        return '9';
      case 10:
        return 'c';
      case 11:
        return 'd';
      case 12:
        return 'a';
      case 13:
        return 'b';
      case 14:
        return 'e';
      case 15:
        return 'f';
      default:
        return 'z';
    }
  }

  private void printSolution() {
    HashSet<Integer> xValues = new HashSet<Integer>();
    HashSet<Integer> yValues = new HashSet<Integer>();
    for (Tuple key: maze.keySet()) {
      xValues.add(key.x);
      yValues.add(key.y);
    }
    Integer[] xVals = xValues.toArray(new Integer[xValues.size()]);
    Integer[] yVals = yValues.toArray(new Integer[yValues.size()]);
    Arrays.sort(yVals, Collections.reverseOrder());
    Arrays.sort(xVals);
    for (Integer y: yVals) {
      for (Integer x: xVals) {
        int room = maze.get(new Tuple(x.intValue(), y.intValue()));
        System.out.print(mapKey(room));
      }
      System.out.print("\n");
    }
  }

  /**
   * Walk the maze by separating the given directions into a forward
   * and backwards set of moves, then tokenizing each set of moves into
   * discrete forward steps and/or turns.
   * @param movesets String containing forward and backwards steps through
   * maze.
   */
  public void walkMaze(String movesets) {
    // Starting room is immediately north of the maze entrance
    currentRoom = new Tuple(0, 1);
    startingRoom = currentRoom;

    for (String moveset: movesets.split(" ")) {
      StringBuilder moves = new StringBuilder();
      for (char move: moveset.toCharArray()) {
        // Split the moveset into chunks delimited by W's so we can
        // process the maze per room instead of per move
        moves.append(move);
        if (move == 'W') {
          updateRoom(moves.toString());
          moves = new StringBuilder();
        }
      }
      // Set the ending room
      if (endingRoom == null) { endingRoom = currentRoom; }
      // Turn around
      currentFacing = oppositeFacing();
    }
    // Remove the starting point and ending point since they're
    // technically outside the maze
    maze.remove(startingRoom);
    maze.remove(endingRoom);
    printSolution();
 }

  public static void main(String[] args) throws Exception {
    try {
      // Read input, either STDIN or file
      // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      BufferedReader br = new BufferedReader(new FileReader(args[0]));

      // number of test cases is the first line
      int numCases = Integer.parseInt(br.readLine());

      // One maze per line
      String line = br.readLine();
      while (line != null) {
        // Instantiate class so we can call non-static methods
        AlwaysTurnLeft atl = new AlwaysTurnLeft();

        atl.walkMaze(line);

        // Read in the next line/maze
        line = br.readLine();
      }
    } catch (Exception e) {
      /* Something terrible happened
       * java.lang.ArrayIndexOutOfBoundsException
       * java.io.FileNotFoundException
       */
      System.out.println(String.format("Something terrible happened: %s", e));
    }
  } // end main

} // end AlwaysTurnLeft
